## Copyright (C) 2018 Sven Durchholz## ## This program is free software: you can redistribute it and/or modify it## under the terms of the GNU General Public License as published by## the Free Software Foundation, either version 3 of the License, or## (at your option) any later version.## ## This program is distributed in the hope that it will be useful, but## WITHOUT ANY WARRANTY; without even the implied warranty of## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the## GNU General Public License for more details.## ## You should have received a copy of the GNU General Public License## along with this program.  If not, see## <https://www.gnu.org/licenses/>.## -*- texinfo -*- ## @deftypefn {} {@var{retval} =} initClusters (@var{input1}, @var{input2})#### @seealso{}## @end deftypefn## Author: Sven Durchholz <Sven Durchholz@STARDUST>## Created: 2018-05-29function  [assignments, centroids, mse] = kMeans(X, k, centroids = 0,   distMeasure = "Euclidean", maxIterations = 100, eps = 0.0001)	  % Initialize Centroids if not given (random)  if (centroids == 0)    centroids = rand(k,2);	endif  	N = length(X(:,1));	dims = length(X(1,:));    % iterate	for i = 1:maxIterations        assignment = ones(1,N);        if (distMeasure == "Euclidean")      % Transpose X and W (wrong initialization)      Xt = X';      Wt = centroids';      D = sqrt(-2*(Wt'*Xt)+repmat(sum(Wt.^2)',1,N)+repmat(sum(Xt.^2),k,1));      [minDist, assignments] = min(D);    endif          if (distMeasure == "Manhatten")      % Formula? D=?      % Fill by iteration instead      % iterate all values (rows)      for row = 1:N        minDist = realmax;        assignTo = 0;                % iterate clusters        for centroid = 1:k                   % Calculate Manhatten distance            D(centroid,row) = sum(abs((X(row,:)-centroids(centroid,:))));          % make assignment, if distance is minimal          if D(centroid,row) < minDist            minDist = D(centroid,row);            assignTo = centroid;          endif        endfor      % add assignemnt to assignment list		  assignments(row) = assignTo;      endfor    endif            % Calculate new Centroids  		newCentroids = zeros(k, dims);    for centroid = 1:k       % get indexes      idx = (assignments==centroid);      % Get all points in cluster      clusterPoints = X(idx,:);            % Reinit if cluster is empty!      if (length(clusterPoints) == 0)        printf("Reinitialize Cluster")        centroids = rand(k,2);        continue			endif            % Calculate Mean (Euclidiean)      if (distMeasure == "Euclidean")        newCentroids(centroid, :) = sum(clusterPoints)/length(clusterPoints(:,1));      endif            % Calculate Median (Manhatten)      if (distMeasure == "Manhatten")        newCentroids(centroid,:) = median(clusterPoints);      endif    endfor            % Calculate Mean Squared error       % Save mse per iteration (for visualization!)    mse(i) = 0;    for row = 1:N        % Sum up all errors distances      % Calculate: Euclidean Distance of point to according centroid      mse(i) += sqrt(sum((X(row, :) - newCentroids(assignments(row), :)).^2));    endfor    % Divide by Number of Points!    mse(i) = (mse(i) / N);          % Stopping criteria    % At least second iteration (to access mse(i-1))    if(i > 1)      % Calculate diff according to given formula. Take absolute!		  diff = (abs((mse(i-1)-mse(i)))/mse(i-1));      if diff < eps        break;      endif	  endif    		centroids = newCentroids;  endfor	    assignments = assignments';  mse = mse';	%printf('i: %d, diff: %f\n', i, diff);endfunction