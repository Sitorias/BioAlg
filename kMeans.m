## Copyright (C) 2018 Sven Durchholz## ## This program is free software: you can redistribute it and/or modify it## under the terms of the GNU General Public License as published by## the Free Software Foundation, either version 3 of the License, or## (at your option) any later version.## ## This program is distributed in the hope that it will be useful, but## WITHOUT ANY WARRANTY; without even the implied warranty of## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the## GNU General Public License for more details.## ## You should have received a copy of the GNU General Public License## along with this program.  If not, see## <https://www.gnu.org/licenses/>.## -*- texinfo -*- ## @deftypefn {} {@var{retval} =} initClusters (@var{input1}, @var{input2})#### @seealso{}## @end deftypefn## Author: Sven Durchholz <Sven Durchholz@STARDUST>## Created: 2018-05-29function  [assignments, centroids, error] = kMeans(X, k, centroids = 0,   mode = 1, maxIterations = 100, eps = 0.0001)	  % Initialize Centroids if not given (random)  if (centroids == 0)    centroids = rand(k,2);	endif  	N = length(X(:,1));	dims = length(X(1,:));    % create an assignemnt list	assignments = ones(1, N);  % iterate	for i = 1:maxIterations    % For each cluster, save sizes of cluster and totals (for mean calculation)		clusterTotals = zeros(k, dims);		clusterSizes = zeros(k, 1);    % iterate all rows		for row = 1:N			minDist = realmax;			assignTo = 0;            % iterate clusters			for centroid = 1:k               if mode == 1				  % Calculate Euclidean distance of point to centroid				  dist = sqrt(sum((X(row, : ) - centroids(centroid, :)).^2));        endif        if mode == 2          % Calculate Manhatten distance          dist = sum(abs((X(row,:)-centroids(centroid,:))));        endif        % make assignment, if distance is minimal				if dist < minDist					minDist = dist;					assignTo = centroid;				endif			endfor            % add assignemnt to assignment list			assignments(row) = assignTo;			% Add values to the cluster total / size for later calculation			clusterTotals(assignTo, :) += X(row, :);			clusterSizes(assignTo)++;      endfor      		% If a cluster is empty choose a random data point as new 		% cluster center		for cluster = 1:k			if (clusterSizes(cluster) == 0)				randomRow = round(1 + rand() * (N - 1) );				clusterTotals(cluster, :) =  X(randomRow, :);				clusterSizes(cluster) = 1;			endif		endfor        % Caluclate new Centroids		newCentroids = zeros(k, dims);		for centroid = 1:k 			newCentroids(centroid, :) = clusterTotals(centroid, : ) / clusterSizes(centroid);		endfor            % Calculate Error       % With Euclidean Distance    if mode == 1      error(i) = 0;      for row = 1:N              error(i) += sqrt(sum((X(row, : ) - newCentroids(assignments(row), :)).^2));      endfor      error(i) = (error(i) / N);    endif    % With Manhatten Distance    if mode == 2      for row = 1:N        % caluclate all rows        errorRow(row) = sum(abs((X(row,:)-newCentroids(assignments(row), :))));      endfor      %Calculate Median      error(i) = median(errorRow);    endif            if(i > 1)		  diff = (abs((error(i-1)-error(i)))/error(i-1));      if diff < eps        break;      endif	  endif    		centroids = newCentroids;	endfor	  assignments = assignments';  error = error';	%printf('i: %d, diff: %f\n', i, diff);endfunction