% kMeans implementation% Return%   assignment -> Row Vector of assigned clusters (number of k)%   centroids -> final centroids%   mse -> Vector of all MSE for each iteration% Param%   X -> Input Matrix%   k -> Number of cluster%   centroids -> Init centroids, if none create random%   distMeasure -> Which Measurement to be used (Euclidean or Manhatten)%   maxIterations -> max number of iterations%   eps -> minimal difference / stopping critera%% Note: Euclidean is calculated by using matrix multiplication%       Manhatten by iteration (How to do this with Matrix Mult?)%       -> Manhatten is significantly slower!function  [assignments, centroids, mse] = kMeans(X, k, centroids = 0,   distMeasure = "Euclidean", maxIterations = 100, eps = 0.0001)	  % Initialize Centroids if not given (random)  if (centroids == 0)    centroids = rand(k,2);	endif  	N = length(X(:,1));	dims = length(X(1,:));    % iterate	for i = 1:maxIterations        assignment = ones(1,N);        if (distMeasure == "Euclidean")      % Transpose X and W (was working with row vectors / row matrices!)      Xt = X';      Wt = centroids';      D = sqrt(-2*(Wt'*Xt)+repmat(sum(Wt.^2)',1,N)+repmat(sum(Xt.^2),k,1));      [minDist, assignments] = min(D);    endif          if (distMeasure == "Manhatten")      % Formula? D=?      % Fill by iteration instead      % iterate all values (rows)      for row = 1:N        minDist = realmax;        assignTo = 0;                % iterate clusters        for centroid = 1:k                   % Calculate Manhatten distance            D(centroid,row) = sum(abs((X(row,:)-centroids(centroid,:))));          % make assignment, if distance is minimal          if D(centroid,row) < minDist            minDist = D(centroid,row);            assignTo = centroid;          endif        endfor      % add assignemnt to assignment list		  assignments(row) = assignTo;      endfor    endif            % Calculate new Centroids  		newCentroids = zeros(k, dims);    for centroid = 1:k       % get indexes      idx = (assignments==centroid);      % Get all points in cluster      clusterPoints = X(idx,:);            % Reinit if cluster is empty!      if (length(clusterPoints) == 0)        printf("Reinitialize Cluster")        centroids = rand(k,2);        continue			endif            % Calculate Mean (Euclidiean)      if (distMeasure == "Euclidean")        newCentroids(centroid, :) = sum(clusterPoints)/length(clusterPoints(:,1));      endif            % Calculate Median (Manhatten)      if (distMeasure == "Manhatten")        newCentroids(centroid,:) = median(clusterPoints);      endif    endfor            % Calculate Mean Squared error       % Save mse per iteration (for visualization!)    mse(i) = 0;    for row = 1:N        % Sum up all errors distances      % Calculate: Euclidean Distance of point to according centroid      mse(i) += sqrt(sum((X(row, :) - newCentroids(assignments(row), :)).^2));    endfor    % Divide by Number of Points!    mse(i) = (mse(i) / N);          % Stopping criteria    % At least second iteration (to access mse(i-1))    if(i > 1)      % Calculate diff according to given formula. Take absolute!		  diff = (abs((mse(i-1)-mse(i)))/mse(i-1));      if diff < eps        break;      endif	  endif    		centroids = newCentroids;  endfor	    % Return as row vectors  assignments = assignments';  mse = mse';endfunction